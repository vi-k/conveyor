# TODO

## LinkedList
- Проверка на зацикливание: item.insertAfter(item);

## Conveyor
- сейчас можно запустить одно и тоже событие дважды
- написать где-то, что после await проверка не происходит
- при запуске дочернего неотменяемого процесса рутовый процесс должен на время
  становиться неотменяемым
- возможно, всё-таки можно/стоит добавить отмену рутовых Futures.
  отделить так: перехватываем в runZoned, а функцию запускаем в новом
  runZoned, создавая вложенные таймеры через родительскую зону.
- добавить что-то типа state.scope, чтобы не использовать каждый раз state.isA,
  когда их много и когда мы не можем указать нужный WorkingState, т.к. он
  меняется.
- Возможность поставить конвейер на паузу.
- Метод взятия следующего события (чтобы не только первое).
- Запустить последнее событие (при диспоузе, чтобы не добавлялись новые)

Тесты:
- ошибка в процессе после его отмены.
- тест на debugInfo
- тест неотменяемых и неудаляемых событий
- тест незавершённых внутренних событий

Примеры:
Простые кейсы
Droppable:
Одноразовое выполнение какого-то процесса по нажатию кнопки. Двойное нажатие
не запускает второй процесс.

Restartable:
Загрузка постоянно меняющихся данных
Ошибки сети: 500, timeout, many requests
Переключение на другой сервер?

Debounce:
- Набор поисковой строки на клавиатуре (debounce)

Sequential:
-
Какой-то простой пример загрузки:
-
Работа с каким-то оборудованием:
Пусть это будет камера, способная менять своё состояние

!!! yield выполняет очередь микротасок после себя

Кажется, restartable не должен удалять ранние события до запуска. Сейчас
удаляет на этапе добавления в очередь. Но если после предыдущего идут ещё
события... А может и нормально

Нужен ли state.test().isA().run?
state.map().run?
Последнее выглядит интересно
проверка этого stateProvider приводит к отмене родительского процесса

state.run().map.isA.it?

state.stream;


-----
Пример:

При накоплении однотипных событий, меняющих разные данные в одной сущности,
можно их аккумулировать в одно!!!

Отправка метрик/логирование: также можно аккумулировать в одно. А может ещё
и как-то добавить задержку для аккумуляции?

Можно это делать во время добавления события, а можно во время исполнения.
