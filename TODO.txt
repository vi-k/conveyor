# TODO

## LinkedList
- Проверка на зацикливание: item.insertAfter(item);

## Conveyor
- сейчас можно запустить одно и тоже событие дважды
- написать где-то, что после await проверка не происходит
- при запуске дочернего неотменяемого процесса рутовый процесс должен на время
  становиться неотменяемым
- возможно, всё-таки можно/стоит добавить отмену рутовых Futures.
  отделить так: перехватываем в runZoned, а функцию запускаем в новом
  runZoned, создавая вложенные таймеры через родительскую зону.

Тесты:
- ошибка в процессе после его отмены.
- тест на debugInfo
- тест неотменяемых и неудаляемых событий
- тест незавершённых внутренних событий

Примеры:
Простые кейсы
Droppable:
Одноразовое выполнение какого-то процесса по нажатию кнопки. Двойное нажатие
не запускает второй процесс.

Restartable:
Загрузка постоянно меняющихся данных
Ошибки сети: 500, timeout, many requests
Переключение на другой сервер?

Debounce:
- Набор поисковой строки на клавиатуре (debounce)

Sequential:
-
Какой-то простой пример загрузки:
-
Работа с каким-то оборудованием:
Пусть это будет камера, способная менять своё состояние

!!! yield выполняет очередь микротасок после себя

Кажется, restartable не должен удалять ранние события до запуска. Сейчас
удаляет на этапе добавления в очередь. Но если после предыдущего идут ещё
события... А может и нормально

Нужен ли state.test().isA().run?
state.map().run?
Последнее выглядит интересно
проверка этого stateProvider приводит к отмене родительского процесса

state.run().map.isA.it?

state.stream;
